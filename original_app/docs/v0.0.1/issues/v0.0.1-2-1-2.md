# Title: v0.0.1-2-1-2 - Update Messages Component to Display User Details

## Summary: 
Update the frontend Messages component to display user full names and roles instead of user IDs, with role badges, timestamps, and improved conversation list styling.

### Acceptance Criteria:
- [ ] Conversation list displays user full_name instead of "User {userId}"
- [ ] Role badges displayed for each user (visual indicator for customer/tasker)
- [ ] Last message preview truncated at 50 characters with ellipsis
- [ ] Timestamps displayed in relative format ("2 hours ago") for recent messages
- [ ] Timestamps display full date/time for messages older than 24 hours
- [ ] Conversations sorted by most recent message first
- [ ] CSS styling matches design system
- [ ] Empty state handled gracefully ("No messages yet")
- [ ] Component works correctly with screen readers

### Test Strategy:

**Unit Tests (Jest/React Testing Library):**
- Test conversation list renders user names correctly
- Test role badges display for customer and tasker
- Test timestamp formatting (relative and absolute)
- Test conversation sorting by recency
- Test empty state rendering
- Test truncation of long message previews

**Tools:** Jest, React Testing Library
**Coverage Target:** >85%

---

## ðŸ–¥ï¸ Front End Components (If Applicable)

**Component Name:** `Messages.js`

**Description:**
Enhanced conversation list that displays rich user information and improved formatting for better UX.

**Code:**

```jsx
// app/frontend/src/components/Messages.js

import React, { useState, useEffect } from 'react';
import { getMessages, sendMessage, markAsRead } from '../api';

const Messages = ({ user }) => {
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [messageContent, setMessageContent] = useState('');
  
  useEffect(() => {
    loadMessages();
  }, []);
  
  const loadMessages = async () => {
    try {
      const messages = await getMessages();
      // Group messages by conversation partner
      const grouped = groupMessagesByPartner(messages, user.id);
      setConversations(grouped);
    } catch (error) {
      console.error('Error loading messages:', error);
    }
  };
  
  const groupMessagesByPartner = (messages, currentUserId) => {
    const conversationMap = {};
    
    messages.forEach(msg => {
      const partnerId = msg.sender_id === currentUserId 
        ? msg.receiver_id 
        : msg.sender_id;
      
      if (!conversationMap[partnerId]) {
        conversationMap[partnerId] = {
          partnerId,
          partnerName: msg.sender_id === currentUserId 
            ? msg.receiver_name 
            : msg.sender_name,
          partnerRole: msg.sender_id === currentUserId 
            ? msg.receiver_role 
            : msg.sender_role,
          messages: [],
          lastMessage: msg,
          unreadCount: 0
        };
      }
      
      conversationMap[partnerId].messages.push(msg);
      
      // Count unread messages received by current user
      if (msg.receiver_id === currentUserId && !msg.read) {
        conversationMap[partnerId].unreadCount++;
      }
    });
    
    // Sort by most recent message
    return Object.values(conversationMap).sort((a, b) => 
      new Date(b.lastMessage.created_at) - new Date(a.lastMessage.created_at)
    );
  };
  
  const formatTimestamp = (timestamp) => {
    const now = new Date();
    const messageDate = new Date(timestamp);
    const diffMs = now - messageDate;
    const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
    
    if (diffHours < 24) {
      if (diffHours < 1) {
        const diffMins = Math.floor(diffMs / (1000 * 60));
        return diffMins < 1 ? 'Just now' : `${diffMins} min ago`;
      }
      return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;
    }
    
    return messageDate.toLocaleDateString() + ' ' + messageDate.toLocaleTimeString();
  };
  
  const truncateMessage = (text, maxLength = 50) => {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  };
  
  const handleSelectConversation = async (conversation) => {
    setSelectedConversation(conversation);
    
    // Mark unread messages as read
    const unreadMessages = conversation.messages.filter(
      msg => msg.receiver_id === user.id && !msg.read
    );
    
    for (const msg of unreadMessages) {
      await markAsRead(msg.id);
    }
    
    // Reload messages to update read status
    await loadMessages();
  };
  
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!messageContent.trim() || !selectedConversation) return;
    
    try {
      await sendMessage({
        receiver_id: selectedConversation.partnerId,
        content: messageContent,
        task_id: selectedConversation.lastMessage.task_id
      });
      
      setMessageContent('');
      await loadMessages();
    } catch (error) {
      console.error('Error sending message:', error);
      alert('Failed to send message');
    }
  };
  
  return (
    <div className="messages-container">
      <div className="conversations-panel">
        <h2>Messages</h2>
        {conversations.length === 0 ? (
          <p className="empty-state">No messages yet</p>
        ) : (
          <div className="conversation-list">
            {conversations.map(conv => (
              <div
                key={conv.partnerId}
                className={`conversation-item ${
                  selectedConversation?.partnerId === conv.partnerId ? 'active' : ''
                }`}
                onClick={() => handleSelectConversation(conv)}
              >
                <div className="conversation-header">
                  <span className="partner-name">{conv.partnerName}</span>
                  <span className={`role-badge ${conv.partnerRole}`}>
                    {conv.partnerRole}
                  </span>
                  {conv.unreadCount > 0 && (
                    <span className="unread-badge">{conv.unreadCount}</span>
                  )}
                </div>
                <p className="last-message">
                  {truncateMessage(conv.lastMessage.content)}
                </p>
                <span className="timestamp">
                  {formatTimestamp(conv.lastMessage.created_at)}
                </span>
              </div>
            ))}
          </div>
        )}
      </div>
      
      <div className="message-thread-panel">
        {selectedConversation ? (
          <>
            <div className="thread-header">
              <h3>{selectedConversation.partnerName}</h3>
              <span className={`role-badge ${selectedConversation.partnerRole}`}>
                {selectedConversation.partnerRole}
              </span>
            </div>
            
            <div className="message-thread">
              {selectedConversation.messages.map(msg => (
                <div
                  key={msg.id}
                  className={`message ${
                    msg.sender_id === user.id ? 'sent' : 'received'
                  }`}
                >
                  <p>{msg.content}</p>
                  <span className="timestamp">
                    {formatTimestamp(msg.created_at)}
                  </span>
                </div>
              ))}
            </div>
            
            <form onSubmit={handleSendMessage} className="message-form">
              <input
                type="text"
                value={messageContent}
                onChange={(e) => setMessageContent(e.target.value)}
                placeholder="Type your message..."
              />
              <button type="submit">Send</button>
            </form>
          </>
        ) : (
          <div className="no-conversation-selected">
            <p>Select a conversation to view messages</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Messages;
```

---

## Issue Dependencies

**Depends on:**
- v0.0.1-2-1-1 - Add User Details to Message Endpoint Response (Backend)

**Blocks:**
- v0.0.1-2-2-1 - Message Tasker Button Integration

## Related Issues

- v0.0.1-2-1-1 - Add User Details to Message Endpoint Response
- v0.0.1-2-3-2 - Add Unread Badges to Frontend