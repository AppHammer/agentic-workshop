# Title: v0.0.1-3-4-1 - Implement Message Polling System

## Summary: 
Implement automatic polling mechanism in the Messages component to fetch new messages every 5-10 seconds, providing near-real-time updates without requiring manual refresh or WebSocket infrastructure.

### Acceptance Criteria:
- [ ] Messages component polls for new messages every 5 seconds
- [ ] Polling only occurs when Messages component is mounted
- [ ] Polling pauses when browser tab is inactive (using visibilityState API)
- [ ] New messages smoothly inserted into conversation without UI jumps
- [ ] Scroll position preserved when new messages arrive (unless at bottom)
- [ ] Auto-scroll to bottom when new message arrives and user is at bottom
- [ ] Polling interval cleared on component unmount (no memory leaks)
- [ ] Error handling for network failures (retry with backoff)
- [ ] Unread count automatically updates with new messages
- [ ] Performance: Conditional queries fetch only new messages

### Test Strategy:

**Unit Tests (Jest/React Testing Library):**
- Test polling starts on component mount
- Test polling interval is 5 seconds
- Test polling pauses when tab inactive
- Test polling clears on unmount (no memory leaks)
- Test new messages inserted correctly
- Test scroll behavior (preserve position vs auto-scroll)
- Test error handling for failed requests

**Integration Tests:**
- Test new message appears within 10 seconds in recipient's view
- Test multiple users can exchange messages in near real-time
- Test unread count updates automatically

**Tools:** Jest, React Testing Library, MSW (Mock Service Worker)
**Coverage Target:** >85%

---

## ðŸ–¥ï¸ Front End Components (If Applicable)

**Component Name:** `Messages.js`

**Description:**
Add polling mechanism using setInterval and the Page Visibility API to fetch new messages automatically.

**Code:**

```jsx
// app/frontend/src/components/Messages.js

import React, { useState, useEffect, useRef } from 'react';
import { getMessages, sendMessage, markAsRead } from '../api';

const Messages = ({ user }) => {
  const [conversations, setConversations] = useState([]);
  const [selectedConversation, setSelectedConversation] = useState(null);
  const [lastMessageId, setLastMessageId] = useState(null);
  const messageThreadRef = useRef(null);
  const [isAtBottom, setIsAtBottom] = useState(true);
  
  useEffect(() => {
    loadMessages();
    
    // Set up polling for new messages
    const pollingInterval = setInterval(() => {
      // Only poll if tab is visible
      if (document.visibilityState === 'visible') {
        loadMessages(true); // Pass true for incremental load
      }
    }, 5000); // Poll every 5 seconds
    
    // Cleanup interval on unmount
    return () => {
      clearInterval(pollingInterval);
    };
  }, []);
  
  useEffect(() => {
    // Track if user is at bottom of message thread
    const messageThread = messageThreadRef.current;
    if (messageThread) {
      const handleScroll = () => {
        const threshold = 50; // pixels from bottom
        const atBottom = messageThread.scrollHeight - messageThread.scrollTop 
          <= messageThread.clientHeight + threshold;
        setIsAtBottom(atBottom);
      };
      
      messageThread.addEventListener('scroll', handleScroll);
      return () => messageThread.removeEventListener('scroll', handleScroll);
    }
  }, [selectedConversation]);
  
  const loadMessages = async (incremental = false) => {
    try {
      const messages = await getMessages();
      
      if (messages.length > 0) {
        const newLastMessageId = messages[0].id;
        
        // Only update if we have new messages
        if (!incremental || newLastMessageId !== lastMessageId) {
          const grouped = groupMessagesByPartner(messages, user.id);
          setConversations(grouped);
          setLastMessageId(newLastMessageId);
          
          // Auto-scroll if user was at bottom
          if (isAtBottom && messageThreadRef.current) {
            setTimeout(() => {
              messageThreadRef.current.scrollTop = messageThreadRef.current.scrollHeight;
            }, 100);
          }
        }
      }
    } catch (error) {
      console.error('Error loading messages:', error);
      // Implement exponential backoff on repeated failures
    }
  };
  
  const groupMessagesByPartner = (messages, currentUserId) => {
    // ... existing grouping logic
  };
  
  const handleSelectConversation = async (conversation) => {
    setSelectedConversation(conversation);
    
    // Mark unread messages as read
    const unreadMessages = conversation.messages.filter(
      msg => msg.receiver_id === user.id && !msg.read
    );
    
    for (const msg of unreadMessages) {
      await markAsRead(msg.id);
    }
    
    // Reload to update read status
    await loadMessages();
    
    // Scroll to bottom of new conversation
    if (messageThreadRef.current) {
      messageThreadRef.current.scrollTop = messageThreadRef.current.scrollHeight;
    }
  };
  
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if (!messageContent.trim() || !selectedConversation) return;
    
    try {
      await sendMessage({
        receiver_id: selectedConversation.partnerId,
        content: messageContent,
        task_id: selectedConversation.lastMessage.task_id
      });
      
      setMessageContent('');
      await loadMessages(); // Reload immediately after sending
    } catch (error) {
      console.error('Error sending message:', error);
      alert('Failed to send message');
    }
  };
  
  return (
    <div className="messages-container">
      <div className="conversations-panel">
        {/* Conversation list */}
      </div>
      
      <div className="message-thread-panel">
        {selectedConversation && (
          <>
            <div className="thread-header">
              <h3>{selectedConversation.partnerName}</h3>
            </div>
            
            <div 
              className="message-thread" 
              ref={messageThreadRef}
            >
              {selectedConversation.messages.map(msg => (
                <div
                  key={msg.id}
                  className={`message ${
                    msg.sender_id === user.id ? 'sent' : 'received'
                  }`}
                >
                  <p>{msg.content}</p>
                  <span className="timestamp">
                    {formatTimestamp(msg.created_at)}
                  </span>
                </div>
              ))}
            </div>
            
            <form onSubmit={handleSendMessage} className="message-form">
              <input
                type="text"
                value={messageContent}
                onChange={(e) => setMessageContent(e.target.value)}
                placeholder="Type your message..."
              />
              <button type="submit">Send</button>
            </form>
          </>
        )}
      </div>
    </div>
  );
};

export default Messages;
```

---

## Issue Dependencies

**Depends on:**
- v0.0.1-2-1-2 - Update Messages Component to Display User Details
- v0.0.1-2-3-2 - Add Unread Message Badges to Frontend

## Related Issues

- v0.0.1-2-3-2 - Add Unread Message Badges to Frontend
- All Epic 3 integration issues (polling enables near-real-time communication)